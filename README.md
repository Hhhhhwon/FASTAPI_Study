# FAST API 실전 입문 🚀
## 섹션 1: FAST API 알아보기 📚
### FAST API란? 🤔
#### FAST API는 2018년 말에 개발된 현대적인, 고성능 파이썬 웹 프레임워크. 단기간 내에 많은 인기를 얻었으며, GitHub Star History를 통해 그 인기의 상승 곡선을 확인할 수 있다.

### 사용하는 기업 🏢
#### `MicroSoft`, `Uber`, `Netflix`와 같은 글로벌 테크 기업에서도 FAST API를 사용하고 있다. 이는 FAST API의 신뢰성과 성능을 입증하는 강력한 사례. 자세한 내용은 FAST API 공식 문서에서 확인할 수 있다.

### 비교 🆚

| 기능    | Django + DRF        | FASTAPI        |
|-------|-------------------|---------------|
| 구조    | Battery included   | 경량 Framework |
| 확장성  | 제한적              | 자유로움         |
| 성능    |                     | Django보다 우수 |

### FAST API의 장점 🌟
- #### 성능: 고성능을 자랑하며, 비동기 처리가 가능하여 매우 빠른 속도를 제공.

#### 직관적인 디자인:

- #### 경로, 쿼리, 바디, 응답, 의존성을 명확하게 정의할 수 있어 개발자가 API를 더 쉽고 효율적으로 설계할 수 있게 한다.
#### 타입 힌트와 데이터 검증:

- #### Pydantic을 사용한 타입 힌트와 데이터 검증을 통해 오류를 줄이고, IDE(통합 개발 환경) 지원을 통해 개발 속도를 향상시킨다.
#### 비동기 처리:

- #### AsyncIO와 백그라운드 태스크를 통해 I/O 작업이 많은 애플리케이션에서도 뛰어난 성능을 발휘.
#### 자동 문서 생성:

- #### OpenAPI와 SwaggerUI를 사용한 자동 문서 생성 기능으로, 개발자가 아니라도 API를 쉽게 이해하고 사용할 수 있게 해준다.
#### 비전공자를 위한 설명 💡
- #### FAST API는 웹 애플리케이션을 만들기 위한 도구로, 다른 웹 프레임워크에 비해 더 빠른 성능과 간단한 사용법을 제공한다. 복잡한 설정 없이도 쉽게 웹 서비스를 시작할 수 있으며, 특히 데이터를 다루는 서비스를 만들 때 그 효율성을 발휘한다. 이 모든 것이 개발자들 사이에서 FAST API가 급속도로 인기를 얻는 이유이다. 🌈

#### FAST API를 사용하면, 프로그래밍에 대한 깊은 지식이 없는 사람들도 쉽게 그 구조를 이해할 수 있고, 심지어는 자신만의 API를 만드는 데 첫걸음을 떼는 데 도움을 받을 수 있다. 자동으로 생성되는 문서 덕분에, 개발자가 아니어도 API의 작동 방식을 파악하고 사용할 수 있게 된다. 📄👀

## 클라이언트-서버 모델 🌍
### 클라이언트 (👤)
- #### 서비스 요청자: 웹 브라우저나 앱처럼 사용자가 직접 사용하여 서버에 정보나 서비스를 요청하는 역할을 한다.
### 서버 (💻)
- #### 서비스 제공자: 요청받은 서비스나 데이터를 사용자에게 제공하는 컴퓨터 시스템이다. 예를 들어, 웹페이지를 보여주거나, 이메일을 처리하는 등의 역할을 한다.
### 장점 ✨
- #### 확장 가능성 (📈): 하나의 서버가 많은 클라이언트의 요청을 처리할 수 있다. 이는 서비스가 많은 사용자에게 동시에 제공될 수 있음을 의미한다.
- #### 관심사의 분리 (🔒): 서버와 클라이언트의 역할이 분리되어 있어 각각의 시스템이 자신의 역할에 집중할 수 있다. 이를 통해 보안과 성능을 각각 최적화할 수 있다.
### 웹 서비스 🌐
- #### HTTP 요청 (➡️): 클라이언트는 웹 페이지를 요청하기 위해 서버로 HTTP 요청을 보낸다.
- #### HTTP 응답 (⬅️): 서버는 요청받은 웹 페이지나 데이터를 클라이언트에게 HTTP 응답으로 보낸다.
### API (Application Programming Interface) 🛠️
- #### 소프트웨어 간의 "다리" 역할을 하여, 서로 다른 시스템이나 애플리케이션이 서로 통신할 수 있게 해주는 규칙과 도구의 집합이다.
### 인터페이스 예시 🎛️
### 리모컨 📺
- #### 사용자와 장비 사이의 매개체: 사용자는 복잡한 전자기기를 간단한 버튼 조작으로 쉽게 제어할 수 있다. 내부 기능에 대한 세부 사항을 몰라도 기기를 원하는 대로 조작할 수 있다.
### 에어컨 🌬️
- #### <내부>와 <외부>의 상호작용: 사용자는 에어컨을 켜고, 원하는 온도로 설정하며, 바람의 세기를 조절할 수 있다. 사용자는 에어컨의 내부 작동 방식을 알 필요 없이, 원하는 환경을 조성할 수 있다.
### 비전공자를 위한 요약 📝
- #### 클라이언트-서버 모델은 인터넷의 기본 구조이다. 이 모델에서, 사용자(클라이언트)는 서비스나 데이터를 요청하고, 서버는 그 요청을 처리하여 필요한 결과를 제공한다. 이 과정에서 API는 서로 다른 소프트웨어 간에 정보를 교환할 수 있게 해주는 규칙이다. 예를 들어, 스마트폰 앱(클라이언트)이 날씨 정보(서버에서 제공)를 보여주기 위해 사용하는 것이다. 생활 속의 다양한 인터페이스처럼, API도 사용하기 쉬운 방식으로 복잡한 기능을 제공한다. 🌟
## REST API 🌐
### REST, 즉 Representational State Transfer는 서버에서 관리하는 데이터의 상태를 표현하는 방식으로 설계된 웹 아키텍처 스타일. 클라이언트와 서버가 서로 예측 가능한 방법으로 통신할 수 있게 해준다.

### 특징 📌
#### REST API는 주로 리소스(자원, 데이터)와 메소드(작업)로 표현된다.

### Response (응답) 📬
#### URL을 통한 리소스 표현: 각 리소스는 URL(Uniform Resource Locator)을 통해 고유하게 접근할 수 있다.

### 예시:
- #### /api/v1/posts : 게시물 목록을 나타낸다.
- #### /api/v1/posts/123/comments : 게시물 123의 댓글을 나타낸다.
### Method (메소드) 🛠️
- #### HTTP 메소드를 통한 API 동작 표현: API의 동작(작업)은 HTTP 메소드를 통해 표현.

### 예시:
- #### GET /api/v1/posts : 게시물 목록 조회
- #### POST /api/v1/posts : 새 게시물 생성
- #### PATCH /api/v1/posts/123 : 게시물 123 수정
- #### DELETE /api/v1/posts/123 : 게시물 123 삭제
### REST API의 장점 ✨
- #### 단순하고 직관적인 구조로 API를 빠르게 이해하고 사용할 수 있다.
- #### 상태가 없는`(stateless)` 통신을 사용하여 서버가 클라이언트의 상태를 저장하지 않는다. 이는 서버의 처리를 간단하게 만들어 준다.
- #### 다양한 클라이언트 (웹, 모바일, IoT 기기 등)에 서비스를 제공할 수 있는 유연성을 갖추고 있다.
### 비전공자를 위한 설명 💁
- #### REST API는 인터넷 상에서 컴퓨터나 프로그램이 서로 "이야기"하는 방법 중 하나이다. 예를 들어, 여러분이 웹사이트에서 뉴스 기사를 읽거나, 소셜 미디어에 글을 올릴 때, 여러분의 웹 브라우저(클라이언트)는 뉴스 서비스나 소셜 미디어 서버에게 특정 작업(리소스 요청, 글 작성 등)을 요청한다. REST API는 이러한 요청과 응답을 어떻게 처리할지에 대한 규칙을 정의한다.

#### **URL(웹 주소)**은 우리가 찾고자 하는 정보나 서비스(리소스)의 위치를 나타낸다.
#### **HTTP 메소드(작업 유형)**는 우리가 그 리소스에 대해 수행하고자 하는 동작(읽기, 쓰기, 수정, 삭제)을 나타낸다.

## ToDo 서비스 만들기 📝
#### 우리는 이 과정을 통해 FAST API의 기본적인 사용법을 익히고, 단계별로 ToDo 서비스를 발전시켜 나가게 된다.

### GET (조회) 🔍
- #### 전체 ToDo 조회: /api/v1/todos
- #### 이 API를 통해 등록된 모든 ToDo 항목을 조회할 수 있다. 사용자가 할 일 목록을 전체적으로 볼 수 있는 기능이다.
- #### 단일 ToDo 조회: /api/v1/todos/<id>
- #### 특정 ID를 가진 ToDo 항목 하나를 조회. 사용자가 특정 할 일에 대한 세부 사항을 확인할 수 있다.
### POST (생성) ➕
- #### ToDo 생성: /api/v1/todos
- #### 새로운 ToDo 항목을 생성한다. 사용자가 새로운 할 일을 추가할 수 있다.
### PATCH (수정) 📝
- #### ToDo 수정: /api/v1/todos/<id>
- #### 특정 ID를 가진 ToDo 항목을 수정한다. 사용자가 기존 할 일의 내용을 변경할 수 있다.
### ELETE (삭제) ❌
- #### ToDo 삭제: /api/v1/todos/<id>
- #### 특정 ID를 가진 ToDo 항목을 삭제한다. 사용자가 더 이상 필요 없는 할 일을 목록에서 제거할 수 있다.
### FAST API와 함께하는 ToDo 서비스 개발 여정 🚀
- #### 이 과정을 통해 우리는 FAST API를 활용하여 RESTful API를 구현하는 방법을 배우게 된다. 처음에는 기본적인 CRUD(Create, Read, Update, Delete) 기능을 갖춘 간단한 ToDo 서비스를 만들고, 점차 기능을 확장해 나가면서 보다 복잡한 웹 애플리케이션으로 발전시켜 나갈 예정이다.

- #### 섹션 2, 3, 4에서는 섹션 1에서 만든 ToDo 서비스를 기반으로 지속적으로 발전시키는 형태로 진행된다. 사용자 인증, 데이터베이스 연동, 비동기 처리 등 고급 기능을 추가하여, 실제 서비스에 적용 가능한 수준의 애플리케이션을 완성해 나갈 것이다.
### 비전공자를 위한 설명 🌟
- #### ToDo 서비스를 만들면서, 우리는 웹 애플리케이션의 기본 구조와 데이터를 처리하는 방법을 배운다. 각각의 API는 우리가 웹사이트나 앱에서 할 일을 추가, 조회, 수정, 삭제하는 버튼을 눌렀을 때 무슨 일이 일어나는지를 정의합니다. 이 과정에서 우리는 FAST API라는 도구를 사용하여, 이러한 동작들을 구현하는 방법을 학습하게 된다.

- #### GET: 정보를 얻기 위해 서버에 요청을 보내는 행위이다. 마치 도서관에서 책을 찾아보는 것과 비슷하다.
- #### POST: 새로운 정보를 서버에 추가하는 행위이다. 새로운 메모를 달력에 붙이는 것처럼 생각할 수 있다.
- #### PATCH/DELETE: 정보를 수정하거나 삭제하는 행위이다. 이미 쓴 메모를 고치거나, 필요 없어진 메모를 떼어내는 것과 유사하다.

## 프로젝트 구조 설정 📂
#### src 폴더 생성:
#### `todos`라는 이름의 프로젝트 폴더 안에, `src`라는 새 폴더를 만든다. `src`는 `"source"`의 약자로, 우리가 작성할 모든 소스 코드를 이곳에 저장한다.

#### main.py 파일 생성:
#### src 폴더 내에 main.py 파일을 새로 만든다. 이 파일은 우리의 FastAPI 애플리케이션의 진입점(entry point)이 된다.

### FastAPI 애플리케이션 코드 작성 🚀
#### main.py 파일을 열고, 다음 코드를 입력해보자. 이 코드는 매우 기본적인 FastAPI 애플리케이션을 설정한다.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def health_check_handler():
    return {"ping": "pong"}
```
- #### from fastapi import FastAPI: FastAPI 라이브러리에서 FastAPI 클래스를 가져온다.
- #### app = FastAPI(): app이라는 이름의 FastAPI 애플리케이션 인스턴스를 생성한다.
- #### from@app.get("/"): 루트 URL(/)에 대한 GET 요청을 처리하는 데코레이터를 설정한다.
- #### fromdef health_check_handler(): 루트 URL에 대한 요청을 처리할 함수를 정의한다. 이 함수는 {"ping": "pong"}이라는 JSON 응답을 반환한다.
### API 실행하기 🌐
- #### from터미널 열기: 프로젝트 폴더(todos)에서 터미널 또는 커맨드 프롬프트를 연다.

#### 가상 환경 활성화 (이미 활성화되어 있다면 생략 가능):

```bash
C:\project\todos> .\venv\Scripts\activate
```
- #### Uvicorn으로 애플리케이션 실행:

```bash
(venv) C:\project\todos\src> uvicorn main:app --reload
```
- #### uvicorn main:app: main.py 파일에 정의된 app 애플리케이션을 Uvicorn 서버에서 실행한다.
- #### --reload: 코드가 변경될 때마다 서버를 자동으로 재시작한다.
### Swagger UI 접속하기 📄
- #### FastAPI는 Swagger UI를 자동으로 제공합니다. 이는 API를 쉽게 테스트하고 문서화할 수 있는 웹 인터페이스이다.

- #### 애플리케이션이 실행되면, 웹 브라우저를 열고 http://127.0.0.1:8000/docs 주소로 이동해요.
- #### Swagger UI 페이지에서는 API의 모든 라우트와 매개변수를 볼 수 있으며, 직접 API 요청을 보내고 응답을 확인할 수 있다.

### 데이터 구조 정의 📝
```python
todo_data = {
    1: {
        "id": 1,
        "contents": "실전! Fast API 섹션 0 수강",
        "is_done": True,
    },
    2: {
        "id": 2,
        "contents": "실전! Fast API 섹션 2 수강",
        "is_done": True,
    },
    3: {
        "id": 3,
        "contents": "실전! Fast API 섹션 3 수강",
        "is_done": True,
    },
}
```
#### todo_data: 간단한 할 일 목록을 저장하는 딕셔너리. 각 할 일(item)은 고유한 id, 할 일의 내용을 나타내는 contents, 그리고 해당 할 일의 완료 여부를 나타내는 is_done을 키로 가지는 딕셔너리로 구성되어 있다. 🗂️
### 🌐 GET API: 전체 조회 📚 🔍
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/todos")
def get_todos_handler(order: str | None = None):
    # todo_data 딕셔너리의 값을 리스트로 변환하여 반환.
    ret = list(todo_data.values())
    # order 파라미터가 'DESC'인 경우, 할 일 목록을 역순으로 정렬하여 반환.
    if order and order == "DESC":
        return ret[::-1]
    # 그렇지 않으면, 할 일 목록을 그대로 반환.
    return ret
```
- #### @app.get("/todos"): FastAPI 데코레이터를 사용하여 /todos 경로에 대한 GET 요청을 처리하는 함수를 정의합니다. 이 함수는 클라이언트가 할 일 목록을 조회할 때 호출됩니다. 🛣️

- #### def get_todos_handler(order: str | None = None): 할 일 목록을 조회하고 반환하는 핸들러 함수입니다. 선택적으로 order 쿼리 파라미터를 받아들이며, 이 파라미터를 통해 클라이언트는 반환되는 할 일 목록의 정렬 순서를 지정할 수 있다. 🔀

- #### ret = list(todo_data.values()): todo_data 딕셔너리의 값들만을 모아 리스트로 만듭니다. 이 리스트는 각 할 일의 딕셔너리를 요소로 가지며, 이를 통해 클라이언트에게 반환될 데이터를 준비. 📋

- #### if order and order == "DESC": 클라이언트가 order 쿼리 파라미터를 'DESC'로 설정했을 경우, 할 일 목록을 역순으로 정렬하여 반환합니다. 이는 리스트의 슬라이스 기능을 사용하여 구현. [::-1]는 리스트를 역순으로 만드는 파이썬 문법. 🔄

### 중요 포인트 🌟
- #### FastAPI는 Python 타입 힌트를 사용하여 파라미터 타입을 자동으로 검증하고, Swagger UI를 통해 문서를 자동으로 생성. 📄
- #### 함수 내부에서 데이터 처리 로직(여기서는 정렬)을 구현하여, 클라이언트의 요청에 따라 다른 형태의 데이터를 반환할 수 있다. 이러한 유연성은 FastAPI 애플리케이션 개발에서 중요한 장점 중 하나. 🔄
- #### FastAPI 애플리케이션은 uvicorn과 같은 ASGI 서버를 사용하여 실행. Uvicorn은 비동기 Python 서버로, FastAPI 애플리케이션의 비동기 기능을 완벽하게 지원. 🚀

### [::-1]에 대한 설명 🔄
#### [::-1]는 파이썬에서 리스트를 역순으로 만드는 간단하고 효율적인 방법. 이 구문을 사용하여 리스트의 아이템들을 역순으로 빠르게 가져올 수 있다.

#### 슬라이싱의 기본 형태 [start:end:step]에서:
- #### start는 슬라이스의 시작 인덱스입니다.
- #### end는 슬라이스가 끝나는 인덱스(이 인덱스의 요소는 포함하지 않음)이다.
- #### step은 간격을 의미한다.
- #### [::-1]에서 start와 end 부분이 비어 있기 때문에, 리스트의 처음부터 끝까지를 의미합니다.
- #### step 부분에 -1이 오기 때문에, 한 번에 한 요소씩 거꾸로 진행하라는 의미가 된다.
- #### 👉 예를 들어, list[::-1]을 사용하면, list의 모든 요소들이 역순으로 나열된 새로운 리스트를 얻을 수 있다.

### (order: str | None = None) 조건문에 대한 설명 📜
- #### (order: str | None = None)는 파이썬 3.10 이상에서 지원하는 타입 힌팅(type hinting) 문법의 예시이다. 이 구문은 함수의 인자 order가 str 타입의 문자열이거나 None일 수 있음을 나타낸다. = None은 order 인자에 기본값으로 None을 할당하겠다는 의미이다.

- #### 유연성 제공: 사용자가 order 인자에 대해 특정 값을 제공할 수도 있고, 아무것도 제공하지 않을 경우에는 기본값인 None을 사용하게 됩니다.
#### 사용 예시:
- #### get_todos_handler(order="DESC"): 함수를 이렇게 호출하면, order는 "DESC" 값을 가지게 되고, 함수 내에서 조건문을 통해 해당 값에 따라 다른 동작을 수행할 수 있다.
- #### get_todos_handler(): 인자 없이 함수를 호출하면, order는 기본값인 None이 되며, 함수는 기본 동작을 수행하게 된다.

## 🕵️‍♂️ GET API: 단일 조회 🔍
### API 엔드포인트 설명 🌍
```python
@app.get("/todos/{todo_id}")
def get_todo_handler(todo_id: int):
    return todo_data.get(todo_id, {})
```
- #### @app.get("/todos/{todo_id}"): 이 데코레이터는 특정 할 일 항목을 조회하기 위한 경로를 설정. 여기서 {todo_id}는 경로 변수(path variable)로, 조회하고자 하는 할 일 항목의 고유 ID를 나타낸다.

- #### def get_todo_handler(todo_id: int): 이 함수는 할 일 항목의 ID를 기반으로 해당 항목을 조회하고 반환하는 역할을 합니다. todo_id: int 부분은 todo_id 매개변수가 정수형(int) 데이터임을 나타내는 타입 힌트. 즉, 사용자가 URL을 통해 전달하는 todo_id 값이 정수여야 함을 의미.

- #### return todo_data.get(todo_id, {}): todo_data 딕셔너리에서 todo_id에 해당하는 항목을 찾아 반환. .get() 메소드는 딕셔너리에서 특정 키에 해당하는 값을 가져오는 데 사용된다. 만약 해당 키(todo_id)가 딕셔너리에 존재하지 않는다면, 기본값으로 빈 딕셔너리 {}를 반환. 이는 존재하지 않는 ID에 대한 요청이 있을 때 오류 대신 안전하게 빈 결과를 제공하기 위함.

### 사용 예시 📖
- #### 만약 사용자가 웹 브라우저나 API 테스팅 도구(Postman 등)을 사용하여 http://localhost:8000/todos/1에 접근한다면, todo_id가 1인 할 일 항목을 조회하려는 요청으로 간주.

- #### 이때, todo_data 딕셔너리 내에 ID가 1인 항목이 존재한다면 해당 항목의 데이터가 JSON 형태로 반환.

- #### 만약 ID가 1인 항목이 없다면, 빈 딕셔너리 {}가 반환됩니다. 이는 사용자에게 "요청한 ID의 할 일 항목이 없음"을 안전하게 알리는 방법.

## 📝 POST API 생성
### Pydantic을 임포트합니다. Pydantic은 데이터 검증 및 설정 관리를 위한 라이브러리.
```py
from pydantic import BaseModel 

# 할 일(Todo) 항목을 생성하기 위한 데이터 모델을 정의.
class CreateToDoRequest(BaseModel):
    id: int       # 할 일 항목의 고유 ID
    contents: str # 할 일 항목의 내용
    is_done: bool # 할 일 항목의 완료 여부

# '/todos' 경로에 대한 POST 요청을 처리하는 함수를 정의.
@app.post("/todos")
def create_todo_handler(request: CreateToDoRequest):
    # 요청 받은 데이터를 todo_data 딕셔너리에 저장.
    # 만약 .dict() 대신 model_dump()를 사용해야 한다는 경고가 나오면 아래와 같이 변경.
    todo_data[request.id] = request.model_dump()
    todo_data[request.id] = request.dict()

    # 저장된 할 일 항목을 반환.
    return todo_data[request.id]
```
### CURL 명령어 예시 🖥️
```py
curl -X 'POST' \
  'http://127.0.0.1:8000/todos' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "id": 4,
  "contents": "실전! FastAPI 섹션 3 수강",
  "is_done": false
```
#### 이 CURL 명령은 새로운 할 일 항목을 서버에 생성하기 위해 http://127.0.0.1:8000/todos 주소로 POST 요청을 보내는 방법을 보여준다.
- #### -H 'accept: application/json' 헤더는 서버에게 JSON 형식의 응답을 기대한다는 것을 알린다. 📄
- #### -H 'Content-Type: application/json' 헤더는 요청 본문이 JSON 형식임을 명시한다. 🗂️
- #### -d '{...}'는 서버로 전송될 데이터를 포함한다. 여기서는 id, contents, is_done의 세 가지 - #### 필드를 JSON 객체로 구성하여 보내고 있다. 📤
### 중요 포인트 🌟
- #### 데이터 검증: Pydantic BaseModel을 사용하여 요청 데이터의 유효성을 검증한다. 각 필드는 타입 힌트를 통해 데이터 타입이 지정된다.

- #### 딕셔너리 변환: .dict() 메서드를 사용하여 Pydantic 모델 인스턴스를 딕셔너리로 변환하고, 이를 todo_data 저장소에 저장합니다(최신버전은 `model_dump()`인거 같다).

- #### 응답 반환: 함수는 최종적으로 저장된 할 일 항목을 클라이언트에게 JSON 형식으로 반환.

## 🛠️ PATCH API 수정
```py
# FastAPI 프레임워크와 Body 함수를 임포트.
from fastapi import FastAPI, Body

# FastAPI 앱 인스턴스를 생성. 이 인스턴스로 웹 애플리케이션을 구성하고 실행할 수 있다.
app = FastAPI()

# 간단한 예제 데이터. 실제 애플리케이션에서는 데이터베이스나 다른 저장소가 사용될 수 있다.
todo_data = {
     1: {
        "id": 1,
        "contents": "실전! Fast API 섹션 0 수강",
        "is_done": True,
    },
    2: {
        "id": 2,
        "contents": "실전! Fast API 섹션 2 수강",
        "is_done": True,
    },
    3: {
        "id": 3,
        "contents": "실전! Fast API 섹션 3 수강",
        "is_done": True,
    },
}

# '/todos/{todo_id}' 경로에 대한 PATCH 요청을 처리하는 함수.
@app.patch("/todos/{todo_id}")
def update_todo_handler(
    todo_id: int,  # URL 경로에서 가져온 할 일 항목의 ID. (Path Variable)
    is_done: bool = Body(..., embed=True)  # 요청 본문에서 가져온 완료 상태.
):
    # todo_data 딕셔너리에서 todo_id를 키로 가지는 항목을 조회.
    todo = todo_data.get(todo_id)
    
    # 조회된 할 일 항목이 존재하는 경우
    if todo:
        # 할 일 항목의 완료 상태를 요청받은 is_done 값으로 업데이트.
        todo["is_done"] = is_done
        # 수정된 할 일 항목을 반환.
        return todo
    
    # 해당 ID의 할 일 항목이 존재하지 않는 경우, 빈 딕셔너리를 반환.
    return {}
```
### 중요 포인트 🔑
#### Path Variable (todo_id): 경로 변수는 URL 경로의 일부로, 여기서는 할 일 항목의 고유 ID(todo_id)를 나타냅니다. FastAPI는 이 변수를 함수 매개변수 todo_id로 자동 매핑하여 사용할 수 있게 해줍니다. 🛣️

#### Body 데이터 (is_done): 클라이언트가 요청 본문(Body)에 보낸 데이터입니다. 여기서는 할 일 항목의 완료 상태(is_done)를 나타내며, Body(..., embed=True)를 통해 이 필드가 반드시 요청 본문에 포함되어야 함을 나타냅니다. 📦

#### 데이터 조회 및 업데이트: todo_data.get(todo_id)를 사용하여 주어진 todo_id에 해당하는 할 일 항목을 조회. 조회된 항목이 있으면, 해당 항목의 is_done 속성을 업데이트하고, 수정된 항목을 반환합니다. 만약 해당하는 항목이 없으면, 빈 딕셔너리 {}를 반환. 🔄

## ❌ DELETE API: 삭제하기


